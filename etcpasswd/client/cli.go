package client

import (
	"bufio"
	"crypto/tls"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"
)

const userAgent = "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0 - github.com/nullfil3/)"

//NewClient client for http requests
func NewClient() *http.Client {
	tr := &http.Transport{
		MaxIdleConns:    30,
		IdleConnTimeout: time.Second,
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		DialContext: (&net.Dialer{
			Timeout:   time.Second * 10,
			KeepAlive: time.Second,
		}).DialContext,
	}

	return &http.Client{
		Transport: tr,
		Timeout:   time.Second * 10,
	}
}

//FromStdin Read from stdin
func FromStdin() {
	var wg sync.WaitGroup
	sc := bufio.NewScanner(os.Stdin)
	for sc.Scan() {
		URL := sc.Text()
		wg.Add(1)
		go func() {
			defer wg.Done()
			DotDotReq(URL)
		}()
	}
	wg.Wait()
}

//DotDotReq load payloads list and exec with cli
func DotDotReq(url string) {
	client := NewClient()
	payloads, err := os.Open("./utils/payloads.txt")

	if err != nil {
		log.Fatalln("[!] error while reading the file", err)
	}

	defer payloads.Close()
	scanner := bufio.NewScanner(payloads)

	for scanner.Scan() {
		payload := scanner.Text()
		fmt.Println(payload)
		urlReq := url + payload
		fmt.Println(urlReq)
		req, err := http.NewRequest("GET", urlReq, nil)
		req.Header.Set("User-Agent", userAgent)
		if err != nil {
			log.Fatalln("[!] Erro at request ", urlReq)
		}

		resp, err := client.Do(req)
		if err != nil {
			return
		}

		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Println("[!] Error while reading the body data of", urlReq)
		}

		bodyStr := string(body)

		if strings.Contains(bodyStr, "root:x:") || strings.Contains(bodyStr, "daemon:x") || strings.Contains(bodyStr, "for 16-bit") || strings.Contains(bodyStr, "boot loader") {
			fmt.Printf("[PATHTRAVERSAL][VULNERABLE]: %s\n", urlReq)
		}

		defer resp.Body.Close()

		if err := scanner.Err(); err != nil {
			log.Fatalln(err)
		}
	}
}
